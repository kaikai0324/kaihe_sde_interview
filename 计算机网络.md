

# 计算机网络：

[toc]

## 高频考点

### 1. UDP和TCP的区别

①TCP是面向连接的，UDP是无连接的

②TCP所需资源多，传输速率慢，UDP所需资源少、传输速率快

③TCP的数据传输以**字节流**的形式，UDP的数据传输是以**报文段**的形式

④TCP用检验和、标号、流量控制、拥塞控制、超时重传等机制保证TCP连接是可靠的，UDP则不保证可靠交付，只保证尽力交付

⑤TCP只适用于一对一单播，UDP可用于广播通信

⑥TCP适用于对可靠性要求较高的场景，比如文件的传输等，UDP适用于实时性要求较高的场景，比如微信视频通话等。

### 2. TCP的三次握手、四次挥手

##### 2.1详细过程以及C和S的状态

**三次握手**

首先发起连接的一端称为[客户端]()，被动等待连接的一端称为服务器端

1.[客户端]()向服务器端发送一个同步报文，该TCP报文的首部控制位SYN=1，序列号随机，这里定为x。[客户端]()发出报文后进入SYN-SENT状态

2.服务器接收到报文进入到SYN-RECIVED状态，并返回一个确认报文给[客户端]()，该TCP报文的首部控制位SYN=1,ACK=1,序列号为y(随机)，确认号为x+1

3.[客户端]()接收到服务器端传来的确认报文后进入到established状态，并传送一个确认报文的确认给服务器，该报文的首部字段控制位ACK=1，序列号为x+1，确认号为y+1，此时可以携带数据部分。服务器端接收到该报文后进入到established状态

**四次挥手**

[客户端]()和服务器端如果完成数据传送工作后，均可主动发起连接释放请求，这里假设[客户端]()首先发起连接释放。

1.[客户端]()发送FIN报文给服务器端，并进入到FIN-WAIT1阶段，该FIN报文包括首部字段控制位FIN=1，序列号seq=u，告诉服务器我已完成我的数据传输工作，你这边如果还有数据可以继续传送

2.服务器收到该FIN报文之后进入close-wait阶段，并返回一个确认报文给[客户端]()，该确认报文包括首部控制位ACK=1，seq=v，ack=u+1。[客户端]()收到该确认报文后进入fin-wait2状态，关闭从[客户端]()到服务器端的数据传送。服务器端仍可向[客户端]()传送数据

3.服务器端完成对[客户端]()的数据传送工作之后，服务器端向[客户端]()发送FIN报文，该报文结构包括FIN=1,ACK=1,序列号为w，确认号为u+1，并进入**Last-ACK**状态

4.[客户端]()接收到该FIN报文后，返回确认报文，该确认报文包括首部控制位ACK=1，序列号为u+1，确认号为w+1，并进入time-wait阶段，等待2MSL后确认服务器端收到ACK报文正常断开连接后，[客户端]()关闭。服务器端收到该确认报文，进入closed状态。

**等待2MSL的原因** 确认服务器端是否正常收到了[客户端]()最后发出的确认报文，如果服务器端没有收到的话，过1MSL（报文在网络中的最大存活时间）会重新再发送一次FIN报文给[客户端]()，如果过了2MSL还没有收到新发的FIN报文的话，证明服务器端已经收到确认报文并正常关闭连接，[客户端]()也可以关闭连接啦~

##### 2.2为什么三次握手？为什么四次挥手？

**三次握手的原因**

确保双方间的连接正常建立，如果只有两次握手的话可能会出现一些异常情况，比如：①[客户端]()的SYN连接请求失效(或者发去时间太久,导致了超时重传的发生)，但是服务器端接收到了该SYN报文，如果不经过第三次握手的话服务器端就会错误地开启一个连接；③如果只有两次握手地话，服务器端返回给[客户端]()的确认报文丢失，会导致[客户端]()因为没有收到确认所以关闭了该连接，但服务器端此时已做好了连接准备，造成资源的浪费

**四次挥手的原因**

因为建立连接时双方都处于closed状态，而释放连接时一方收到FIN报文但有可能还有数据要继续传输，不能马上释放连接，所以先返回一个确认报文，发送完数据后再断开连接

### 3. 输入URL到显示网页发生了什么

- **浏览器解析URL对应的IP地址**

 DNS解析过程，浏览器缓存—>操作系统缓存—>本地DNS—>根据转发模式选择迭代还是递归查询

- **浏览器向服务器发送一个HTTP请求报文**

 传输层上建立TCP连接，网络层用到了IP协议(负责在网络层传输数据），还会用到RIP或者OSPF进行路由选择，然后用ARP协议解析IP地址对应的MAC地址，使得数据能够在数据链路层上进行传输（不应该是最后到物理层传输吗）。

 HTTP请求方法有哪些（post/get/head/put/delete）

- **服务器请求处理并返回一个HTTP响应报文**

 HTTP响应报文的结构，状态码

- **服务器返回一个HTML响应，浏览器收到HTML响应并渲染界面

### 4. OSI七层协议及每层作用

**物理层** 

数据以比特流的形式在物理层传输 

设备有中继器、集线器（作用：转发、放大信号）

**数据链路层** 

负责将数据组帧，实现链路管理、流量控制和差错控制 

协议有`GBN后退N帧协议`、`SR选择重传协议`、`以太网协议` 

设备有网桥、交换机（作用：根据MAC地址对帧进行过滤转发，可以隔绝冲突域，不能隔绝广播域）

> **冲突域**：同一时间内只能有一台设备发送信息的范围
>
> **广播域**：网络中能接收到任意设备发出的广播帧的设备的集合

**网络层** 

提供主机和主机之间的逻辑通信

协议有`ARP协议、OSPF/RIP路由寻址协议、DHCP协议、ICMP协议、IGMP组播协议、IP协议、CIDR协议` 

设备有路由器（作用：转发分组）

**传输层** 

提供端到端的可靠报文传递，负责将数据传送至对应端口，提供进程和进程之间的逻辑通信

协议有`TCP UDP协议`

**会话层** 

负责建立、管理、终止进程之间的会话

**表示层** 

对上层数据或者信息进行变换，以保证一个主机应用层信息可以被另一个主机应用层所理解，包括数据加密、格式转换、压缩等

**应用层**

为操作系统或者网络应用程序提供访问网络的接口 协议有`HTTP FTP SMTP DNS协议`

### 5. HTTP和HTTPS的区别

HTTP协议是超文本传输协议，采用[客户端]()/服务器的方式，它的特点是：①无连接，建立在TCP连接的基础之上；②无状态，cookie和session可以辅助记录[客户端]()/服务器的状态

1.HTTP协议运行在TCP之上，不提供身份认证和数据加密，所有数据都是以明文的形式传输的；HTTPS以SSL为安全基础，提供了数据加密和服务器端的身份认证（以对称加密的方式为传输的数据进行加密，用数字证书的方式提供服务器端的身份认证），更为安全

2.HTTPS比HTTP需要耗费更多的资源，响应速度也更慢

3.HTTPS需要CA颁布申请证书，通常不是免费的

4.HTTP和HTTPS是完全不同的连接方式，HTTP端口号是80，HTTPS的端口号是443

### 6. 常见状态码

- 1xx 表示正在处理
  - 100 continue 一切正常 可以继续发送（据说是http报文中如果有post方法的话 会先把请求行发送过去，然后返回100，然后再发送请求头部和请求体给服务器端）
- 2xx 成功 表示请求已经正常处理
  - 200 OK 一切正常返回数据
  - 204 No content 请求正常处理，但是没有数据返回
  - 206 指定范围返回（http1.1以上支持的断点续传功能相关）
- 3xx 重定向 浏览器需要一些额外的操作才能完成请求
  - 301 永久性重定向
  - 302 暂时性重定向（跟http劫持有关，运营商可以通过DNS劫持和http劫持两种，返回一个302，然后让用户跳转到处理好的携带广告的页面）
  - 303 暂时性重定向 但是服务器端明确说明希望浏览器用get方法来请求资源
  - 304 浏览器附带了请求的条件，服务器端允许访问，但是不满足请求条件
- 4xx [客户端]()错误
  - 400 [客户端]()的请求有语法错误
  - 403 forbidden [客户端]()申请访问的资源被禁止访问
  - 404 Not found [客户端]()申请访问的资源不存在
  - 405 Method not allowed [客户端]()请求方法被禁止
- 5xx 服务器端错误
  - 500 服务器在请求处理时内部出错
  - 501 服务器不具备完成请求的功能，如无法识别请求方法
  - 502 服务器作为网关或代理，从上游服务器获得无效响应
  - 503 Bad Gateway 服务器处于停机维护/超负荷状态
  - 504 Gateway timeout服务器作为网关或代理，没有及时从上游服务器获得响应

### 7. cookie和session的区别

首先它们都是用于给无连接的http提供身份认证的功能

cookie是服务器在本机存放的小段文本，并随每一个请求发送至同一服务器。cookie分为会话cookie（不设置过期时间，关闭浏览器窗口cookie即失效，保存在内存中）和持久cookie（设置过期时间，关闭再打开浏览器cookie仍存在，直至达到过期时间）。**类似于检查通行证（即请求报文中附带的cookie）来确定用户身份**

session则一般是利用session id实现的（session id是浏览器第一次发送请求时服务器自动生成的唯一标识，并返回给浏览器），cookie中携带该session id，[客户端]()根据该session id将session检索出来。**类似于在服务器上建立一个客户档案，客户来访时需要查询客户档案**

1.cookie是存放在[客户端]()，用于记录用户信息的，比如自动填充用户名和密码；session是存放在服务器端的，用于记录用户的状态，比如购物车的实现。

2.cookie不太安全，可以分析存放在本地的cookie进行cookie欺骗，（也可以用加密[算法]()加密后进行存放），session存放于服务器的内存中，所以安全性高

3.单个cookie保存数据不能超过4k，session没有对存储数据量的限制

> 禁掉cookie的话session仍然可以使用，但是需要使用其他方法获取session id，比如在url后面或者以表单的形式提交给服务器端

### 8. get和post的区别

> **注意存放在请求行和请求体的不是方法 而是请求/提交的数据啊喂 post和get方法都是在请求行中啦**

1.get数据明文存放在http请求行的url之后，post则是将提交的数据放在http请求报文的请求体中

2.受浏览器对url长度的限制，get传送数据量应不超过2KB。post传送数据量则一般无此限制

3.get只接受acsii字符，post没有限制，get只支持url编码，post没有限制

4.get不能改变服务器的数据，一般用于从服务器获取数据，是幂等的；post可以改变服务器的数据，不是幂等的。

5.get请求可以被浏览器主动缓存，下一次若传输数据相同，则优先返回缓存中的内容，以加快显示速度。post请求不会，除非手动设置一下

6.get请求参数会被完整地保存在浏览器历史记录中，post请求参数则不会保留

### 9.TCP如何保证可靠性

1. **分段** 将报文段分成适合转发的长度

2. **标号** 按照序号判断中间的转发是否有缺失

3. **流量控制** 根据双方的接收发送能力，动态地调整发送方发送窗口的大小，取发送窗口=min(拥塞窗口，接收窗口) （与数据链路层收不下的话返回一个信号告诉发送方自己收不下的流量控制机制不同）

4. **检验和** TCP首部有检验和字段，目的是检验首部+数据部分的数据是否正确，是不是被人篡改或半路出现差错。

5. **超时重传** 发出报文段之后启动定时器，如果重传时间RTT内**没有收到确认**的话，就重传该数据报，也可以采用冗余确认机制（三次接收到同一个ack=k的确认序号，就重传第k个报文段）（快重传中采用的也是冗余重传）

   主要涉及的协议有两种（跟数据链路层的超时重传机制相同）：

   - 停止等待协议 每发送一个报文段就停止，直到收到确认才继续发送，否则超时重传
   - 滑动窗口协议    
     - 后退N帧协议 GBN： 发送窗口>1，接收窗口=1，即接收方必须按照顺序去接收数据，如果启用了超时重传机制的话，就会重传所有当前已经发送但是没有被确认的报文段
     - 选择重传协议 SR： 发送窗口>1，接收窗口>1，即接收方无需按照顺序去接收数据，会按照任意顺序接收所有处于接收窗口内的数据。按照如果启用超时重传机制的话只需要重新发送没有收到确认的数据即可。

6. **拥塞避免** 分为两种：①慢开始，拥塞避免 ②快重传、快恢复
   ![图片说明](https://uploadfiles.nowcoder.com/images/20210330/972694929_1617117127474/154593273E9BAAD4A6E0BBF4F8BA3875)
   检验和的具体工作流程**

**检验和**是TCP和UCP中都有的 要注意检验的是首部和数据字段的有效性

1. 添上伪首部
2. 首部检验和字段置为0
3. 伪首部+首部+data部分用二进制反码求和，并将结果填入到检验和字段
4. 去掉伪首部发送
5. 发送方接受到该数据之后，首先添上伪首部
6. 接着计算伪首部加首部加数据部分的二进制反码求和
7. 如果**全为1**则无差错，去掉伪首部交给网络层，否则丢弃。



### 10.一次完整的http请求：

域名解析
发起TCP3次握手
建立TCP连接后发起http请求
服务器响应请求，返回结果
浏览器得到html标签代码
浏览器解析html代码中的资源，例如js，css，img等
浏览器对页面进行渲染并呈现给用户

客户端向DNS服务器查询域名，用UDP传输。
HTTP是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。



#### 10.1 DNS

DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69。

1.检查浏览器缓存中有没有域名对应的ip地址
2.如果浏览器缓存没有，那么就检查操作系统(windows,linux)的hosts文件
3.local域名系统：如果本地也没有配置那么就会根据向本机配置的本地区DNS域名服务器（LDNS）发起请求，如果你是通过学校连接互联网的一般是你学校的DNS服务器，如果你是在小区连接互联网的一般是网络提供商比如电信，联通的DNS服务器，DNS服务器通常不会太远。
4.root域名系统：如果LDNS也不能解析，那么就直接到根域名服务器请求解析。
如，根域发现这是一个com域（顶级域）的域名，于是返回com域的IP地址，然后运营商的DNS就得到com域的IP地址。
gTLD是国际顶级域名服务器，比如.com,.cn,.org等。

IP数据包在以太网数据包payload里，TCP\UDP数据包在IP数据包payload里： 
以太网数据包：1522，包括22头信息（head）,1500payload
IP数据包：1500，包括20头信息（head），1480payload
TCP数据包：1480，包括20头信息（head），1460payload
UDP数据包：1480，包括8头信息（head），1472payload



#### 10.2 为什么要进行三次握手：

有第三次，是考虑到一种错误情况：假设C发了一请求建立连接的报文，长时间未收到S的确认报文，则C会重发，这个时候S与之建立连接、完成数据通信、关闭了连接，这个时候C第一发出的请求建立连接的报文到达了S,S则会等待C发送数据，实际上C已经CLOSED了，S就一直在这等待，浪费资源，

为什么不是3次挥手：
在客服端第1次挥手时，服务端可能还在发送数据。
所以第2次挥手和第3次挥手不能合并。



### 11.网络层（ip）作用：

网络层的作用是在复杂的网络环境中为要发送的数据报找到一个合适的路径进行传输。

网络层向上提供简单灵活，无连接的，尽最大努力交付的数据报服务。从数据报从主机A发送到主机B的过程中可能要经历很多节点。所谓无连接是指：数据报在传输之前不需要提前规划好整个传输路线，即不用提前建立一条从发送主机到接收主机之间的传输连接路线。（如果是有连接服务，该传输路线建立好之后，各数据报必须在这条路线上传输，经历的结点路径都是相同的）。这就保证了数据传输的简单性。当数据传输到一个节点时，根据网络中的情况在决定通往下一个节点应该走哪条路线。这就保证了数据传输的灵活性。

无连接的传输：当由A向B发送数据报1时，从主机A开始发现由A到节点1的网络比较空闲，就使用这条路径发送，到达节点1时，发现可以使用节点1到节点3的路径，于是就走这条路径，同理再走到主机B；当发送数据报2时，此时发现由A到节点2的网络比较空闲，就使用这条路线发送，之后同理。

所谓尽最大努力交付是指：网络层只保证为数据报找到由主机A到主机B的路径，使数据报能从源端到达目的端，而在发送过程中数据报出现了什么问题（丢失，重复等），网络层不能保证。网络层不能保证数据报的可靠性传输，可靠性则是由网络主机中的传输层来进行保证的。

IP地址：用于标识网络中的唯一一台主机或路由器。路由选择：可以根据数据报的目的地址为其选择合适的传输路径。其中：主机：配有IP地址，但不进行路由选择；路由器：配有IP地址，同时进行路由选择。节点：主机和路由器的统称。







## 常见考点

### 1.IP地址与MAC地址的区别？为啥有了IP地址还需要MAC地址

IP地址是指互联网协议地址（Internet Protocol Address），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

MAC地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家烧入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。

但是如果只用MAC地址的话，因为MAC地址无序杂乱，没有明显规则，难以查找。但是IP是分层的，类似通讯地址，可以根据其网络号找到子网再定义主机，逐级查找，每个设备需要存储的信息较少



##### IP地址和MAC地址的区别主要有： 

1）对于网络上的某一设备，如一台计算机或一台路由器，其IP地址是基于网络拓扑设计出的，同一台设备或计算机上，改动IP地址是很容易的（但必须唯一），而MAC则是生产厂商烧录好的，一般不能改动。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址不可由本地连接内的配置进行修改。如果一个计算机的网卡坏了，在更换网卡之后，该计算机的MAC地址就变了。 

2）长度不同。IP地址为32位，MAC地址为48位。 

3）分配依据不同。IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。 

4）寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。

### 2.ARP协议

作用：实现IP地址到MAC地址的映射（由IP地址获得MAC地址）

流程：根据主机A路由表的内容查找B的IP地址，再从A的**ARP高速缓存**中寻找是否有B的MAC地址，如果没有则**广播ARP请求帧**（构成为`Aip+Bip+A_MAC+全1`）至该局域网内所有的主机。如果主机发现该请求帧中的IP地址与自己的相同则返回一个**单播ARP帧**（构成为`Bip+B_MAC`)返回给主机A，并且**AB均更新自己的ARP高速缓存**。

### 3.http协议的发展历程（1.0 1.1 2.0 3.0）

**http1.0和http 1.1的主要区别是什么？**

1.**连接** HTTP1.0默认使用短连接，每次请求不同的资源都需要重新建立一次连接；HTTP1.1起默认使用长连接，默认开启[keep]()-alive，即同一个TCP连接可以发送和接收多个http请求/响应，这种长连接由流水线方式和非流水线方式，流水线方式是指客户在收到http响应报文之前就能够接着发送新的请求报文，非流水线方式是指客户在收到http响应报文后才能接着发送下一个请求

2.**状态码** HTTP1.1新增24个状态码，409表示请求的资源与资源当前状态发生冲突，410Gone指的是服务器上某个资源被永久删除

3.**带宽优化及网络连接使用** ——http1.1支持断点续传，HTTP1.0中不支持只显示对象的一部分（只能显示全部）、且不支持断点续传功能，浪费带宽；HTTP1.1在请求头中引入了range头域，允许只请求资源的某个部分，返回码是206（partial content）

**http2.0的改进**

1.**头部压缩** 减少冗余头信息，用了首部表来跟踪、存储之前的键值对，相同的数据就无需再每次重复请求和响应了

2.**多路复用** 实现由一个tcp连接并发请求。http1.1多个请求的响应之间会被阻塞

3.**服务器推送**：可以主动将资源推送给[客户端]()缓存中

4.**二进制格式**：采用二进制而非文本格式，将所有传输的信息分割为更小的消息和帧（二进制帧）

### 3. [客户端]()故障检测方法？

**[客户端]()故障检测方法----保活计时器**

目的:在长连接的情况下,检测没有响应的连接并且将其断开(即[客户端]()出现了故障), 防止占用过多的连接资源

[客户端]()打开服务器的连接传送数据后,就保持沉默了,此时有可能[客户端]()出了故障.

解决方法就是使用保活计时器, 每当服务器收到[客户端]()的信息的话,该计时器就复位, 如果两个小时之内还没有收到客户信息,就发送探测报文段,如果发送了10个探测报文段还没有响应的话, 就认为[客户端]()出了故障,终止该连接

### 4. SYN洪泛攻击如何解决？

攻击者伪装成[客户端]()发送TCP的SYN报文, 当服务器返回ACK确认报文之后, 攻击者不再进行确认, 即不回复确认的确认报文, 这个连接就处于一个**挂起**的状态, 服务器收不到确认报文的话, 会启用超时重传机制, 重复发送ACK给攻击者

这样的话,如果攻击者开启大量这种TCP连接, 导致服务器端有很多个挂起的连接, 并且需要重复发送很多ACK给攻击者, 这样就会消耗服务器的内存 可能导致最后服务器死机, 无法正常工作

**解决方法**

- **降低SYN timeout时间** 使得服务器在没收到确认报文后尽快释放半连接的占用
- **采用SYN cookie设置** 给每一个请求连接的ip地址分配一个cookie,短时间内如果连续收到某个IP的重复的SYN报文,就认定收到了攻击,以后会自动丢弃该ip地址传送过来的包


