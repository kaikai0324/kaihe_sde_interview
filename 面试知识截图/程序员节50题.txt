[1024程序员节]你能做对几道？自拟Java选择50题

牛客网瑶瑶公主
10-24 14:34阅读317486
所有题目根据自己笔记自命题，无抄袭，如有错误，欢迎指出。
欢迎自测，答案见文末。
## 题目
**Q1：以下哪些排序属于比较排序？**
```
A.插入排序
B.计数排序
C.交换排序
D.归并排序
```
----
**Q2：以下哪些排序是不稳定的？**
```
A.希尔排序
B.堆排序
C.快速排序
D.冒泡排序
```
---
**Q3：数据规模量较大时，适合的排序算法是？**
```
A.堆排序
B.快速排序
C.归并排序
D.希尔排序
```
-----
**Q4：以下哪些设计模式不属于结构型模式？**
```
A.建造者模式
B.过滤器模式
C.迭代器模式
D.原型模式
```
---
**Q5：定义一个创建对象的接口，让接口的实现类来决定创建哪一种对象，让类的实例化推迟到子类中进行。这是哪种设计模式？**
```
A.简单工厂模式
B.工厂方法模式
C.抽象工厂模式
D.中介者模式
```
---
**Q6：JDK动态代理中，`newInstance` 方法需要的参数不包括哪些？**
```
A.被代理对象的类加载器
B.InvocationHandler 接口的匿名内部类
C.被代理对象实现的接口
D.被代理对象对应类的Class对象
```
---
**Q7：以下关于 char 类型所占内存大小说法正确的是？**
```
A.英文占1B
B.中文在UTF-8编码占2B
C.中文在GBK编码占2B
D.英文占2B
```
---
**Q8：以下关于Java基本数据类型说法错误的是？**
```
A.short的最小范围是-2^15
B.long的最大范围是2^63-1
C.double的有效位数是16位
D.boolean占用内存大小为1B
```
---
**Q9：以下关于String类说法错误的是？**
```
A.对String对象的任何修改都是创建新对象
B.直接使用“+”进行字符串拼接，如果是字面量会自动拼接为一个新的常量
C.StringBuilder或StringBuffer可以直接在原对象上进行修改
D.参与拼接的字符串里有变量，结果可能在栈中，也可能在堆中
```
---
**Q10：在Java中，以下关于值调用和引用调用说法正确的是？**
```
A.Java总是采用按值调用，方法得到的是所有参数值的一个副本
B.当传递对象时实际上方法接收的是这个对象引用的副本
C.方法不能修改基本数据类型的参数
D.方法能修改引用数据类型指向的引用
```
---
**Q11：关于面向对象思想，说法错误的是？**
```
A.封装的主要任务是对属性、数据、部分内部敏感行为实现隐藏，但对属性的访问和修改不一定必须通过公共接口实现
B.面向对象的代码强调低内聚，先抽象模型，定义共性行为，再解决实际问题
C.封装使对象之间的关系变得复杂
D.可以使用里氏替换原则判断是否满足继承关系
```
---
**Q12：以下关于重载和重写说法正确的是？**
```
A.重载中方法名称相同，但参数类型一定不能相同，是水平方向上行为的不同实现
B.重写是指子类实现接口或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直方向上行为的不同实现
C.不管继承关系如何复杂，重载在编译时都一定能够知道调用哪种目标方法
D.重写的子类方法抛出的异常类型不能变小
```
---
**Q13：重载方法选择目标方法的顺序是？**
```
A.精确匹配->基本数据类型->自动拆箱/装箱->向上转型->可变参数
B.基本数据类型->精确匹配->->向上转型->可变参数->自动拆箱/装箱
C.自动拆箱/装箱->向上转型->基本数据类型->可变参数->精确匹配
D.基本数据类型->自动拆箱/装箱->向上转型->精确匹配->可变参数
```
---
**Q14：以下类关系及其英文描述错误的是？**
```
A.继承 is-a
B.关联 links-a
C.组合 has-a
D.聚合 contains-a
```
---
**Q15：以下关于equals和hashCode方法说法正确的是？**
```
A.equals方法必须满足自反性、对称性、传递性、一致性
B.hash码是由对象导出的一个整型值，是没有规律的，每个对象都有一个默认的hash码，值都不同
C.equals相同时候hashCode必须相同
D.hashCode相同时候equals未必相同
```
---
**Q16：以下关于Object类相关方法说明错误的是？**
```
A.clone方法声明为protected，类只能通过该方法克隆它自己及其子类对象
B.重写clone方法只需要指定访问修饰符为public即可
C.只要对象在finalize方法中重新与引用链上的任何一个对象建立关联就会在GC第二次标记时被移出即将回收集合，因为该方法适合释放资源
D.wait/notify/notifyAll方法阻塞或唤醒持有该对象锁的线程。
```
---
**Q17：以下关于Java内部类说法错误的是？**
```
A.静态内部类可以通过`外部类.内部类` 直接访问
B.成员内部类可以访问外部类的所有内容
C.局部内部类的访问修饰符只能为default
D.JVM会把内部类转换成常规的类文件，用美元符号$分隔外部类名与内部类名，其中匿名内部类使用数字进行编号
```
-----
**Q18：以下关于接口和抽象类说法正确的是？**
```
A.定义类的过程就是抽象和封装的过程，而接口和抽象类则是对实体类进行更高层次的抽象，仅定义公共行为和特征
B.抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是has-a关系
C.接口是模板式设计，包含一组具体的特征，例如某品牌特定型号的汽车，底盘、控制电路等是抽象出来的共同特征，但根据不同级别的配置，内饰，显示屏可以存在不同版本的实现。
D.抽象类和接口都不能实例化，没有构造方法
```
---
**Q19：以下关于类初始化顺序正确的是？**
```
A.父类静态代码块/变量->子类静态代码块/变量->父类普通代码块/变量->父类构造方法->子类普通代码块/变量->子类构造方法
B.父类静态代码块/变量->父类普通代码块/变量->父类构造方法->子类静态代码块/变量->子类普通代码块/变量->子类构造方法
C.父类静态代码块/变量->父类普通代码块/变量->子类静态代码块/变量->子类普通代码块/变量->父类构造方法->子类构造方法
D.父类静态代码块/变量->父类构造方法->子类静态代码块/变量->子类构造方法->父类普通代码块/变量->子类普通代码块/变量
```
---
**Q20：以下关于Java序列化说法正确的是？**
```
A.对象序列化保存的是对象的状态，因此类中的静态变量不会被序列化
B.被transient修饰的变量会被设为对应数据类型的默认初始值
C.序列化和反序列化必须保持序列化ID一致，一般使用 `private static final int serialVersionUID` 定义
D.使用Java原生序列化会调用类的无参构造方法
```
---
**Q21：以下哪些方法不能获取ccc包下的Cat类对象cat的Class实例？**
```
A.Cat.class
B.cat.getClass()
C.Class.forName(ccc.Cat)
D.Cat.getClass()
```
---
**Q22：以下关于Java反射说法正确的是？**
```
A.Field类的getType方法返回描述字段类型的一个对象，这个对象的类型是Class
B.动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制
C.Class类的getFields、getMethods和getConstructors方法分别返回这个类支持的公共字段、方法和构造方法的数组，但不包括父类成员
D.Class类的getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法分别返回这个类声明的全部字段、方法和构造方法的数组，其中包括私有成员、包成员和受保护成员，且包括父类的成员。
```
---
**Q23：以下关于注解说法正确的是？**
```
A.元注解就是像@Override这种系统注解的注解
B.注解是一种标记，可以使类或接口附加额外的信息，帮助编译器和JVM完成一些特定功能
C.@Target用来约束注解作用的位置，值是枚举类Element枚举实例，包括METHOD、VARIABLE、TYPE、PARAMETER 、CONSTRUCTORS等
D.@Rentention用来约束注解的生命周期，值是RetentionPolicy枚举实例，包括SOURCE、CLASS和RUNTIME
```
---
**Q24：以下关于异常说法正确的是？**
```
A.Error描述运行时系统的内部错误和资源耗尽错误，例如StackOverFlowException和 OutOfMemoryException，这种异常程序无法处理
B.未授权异常UnAuthorizedException属于非受检异常，处理方法是：程序可跳转至权限申请页面
C.受检异常是需要在代码中显式处理的异常，否则会编译出错，非受检异常是运行时异常，继承自RuntimeException
D.受检异常包括字段超长导致的 SQLException、RPC调用时产生的远程服务超时异常
```
---
**Q25：以下关于泛型说法错误的是？**
```
A.泛型在定义处只具备执行Object方法的能力
B.泛型主要用于编译阶段，在编译后生成的Java字节代码文件中不包含泛型中的任何类型信息
C.对泛型下限的限定使用<? extends T>，对泛型上限的限定使用<? super T>
D.泛型标记N表示自定义类型
```
---
**Q26：以下哪些属于Java8提供的新特性？**
```
A.提供了一个新的cdth引擎，允许在JVM上运行特定的cdth应用
B.加强了类型推测机制，可以使代码更加简洁
C.引入了重复注解机制，相同的注解在同一个地方可以声明多次
D.可以直接引用已有类或对象的方法或构造方法，简化lambda表达式
```
---
**Q27：以下关于JavaIO说法正确的是？**
```
A.BIO是JDK1.4之前的IO机制，可以通过线程池机制改善，这种IO称为伪异步IO
B.NIO是同步非阻塞IO，客户端发送的连接请求都会注册到一个多路复用器Selector上
C.AIO是异步非阻塞IO，任何请求都将对应一个线程,客户端的IO请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程直接使用数据
D.同步和异步是调用机制，阻塞和非阻塞是通信状态
```
-----
**Q28：以下关于NIO说法正确的是？**
```
A.NIO的核心组件是selector、channel和buffer
B.buffer的flip()方法将读模式转为写模式
C.buffer的clear()方法将写模式转为读模式
D.NIO适用场景是连接数目多且连接时间长的情况
```
---
**Q29：以下关于ArrayList说法正确的是？**
```
A.ArrayList实现了RandomAcess接口，这是一个标记接口，如果一个类实现了该接口，表示这个类使用索引遍历比迭代器更快
B.数据域elementData的大小<=size属性的大小
C.每次访问新元素时都会检查modCount和expectedModCount是否相等，如果不相等就会抛出异常，这种机制叫做fail-safe
D.可以使用线程安全的CopyOnWriteArrayList代替ArrayList
```
---
**Q30：以下关于Java集合说法正确的是？**
```
A.LinkedList本质是双向链表，与ArrayList相比插入和删除速度更快，并且支持随机访问元素
B.LinkedList的内存利用率不如ArrayList
C.Vector的实现和ArrayList基本一致，它和ArrayList的区别主要在于增长策略不同，ArrayList多了一个成员变量 capacityIncrement用于标明扩容的增量
D.LinkedList实现了Deque接口
```
---
**Q31：以下关于Set集合说法错误的是？**
```
A.HashSet通过HashMap，HashMap的Key值即HashSet存储的元素，所有Key都使用相同的Value
B.HashSet判断引用类型元素的顺序是：先比较equals()是否相同，如果相同则继续比较hashCode()返回值
C.TreeSet使用TreeMap实现,通过对TreeMap的Vaule排序，保证插入后的集合有序
D.LinkedHashSet继承自HashSet，内部使用链表维护了元素插入的顺序
```
---
**Q32：以下关于红黑树特性说法正确的是？**
```
A.根节点必须是黑色
B.所有NIL节点都是黑色的
C.一条路径上不能出现相邻的两个黑色节点
D.在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点
```
---
**Q33：以下关于TreeMap说法正确的是？**
```
A.TreeMap不但继承了SortedMap，还继承了NavigableMap
B.TreeMap通过重写hashCode和equals方法来达到元素的去重
C.插入的元素必须实现Comparable接口
D.Key允许为 null
```
---
**Q34：以下关于HashMap说法正确的是？**
```
A.HashMap默认初始化容量为16，扩容容量必须是2的幂次方、最大容量为1<<30
B.为了使查询效率尽可能高，应该使键的hash值尽可能分散
C.JDK7的HashMap存在死循环和数据丢失问题
D.JDK8的HashMap在resize方法中完成扩容，并且改用了头插法，不会产生死循环的问题，但是在多线程的情况下还是可能会导致数据覆盖的问题，因此依旧线程不安全
```
---
**Q35：以下关于JVM运行时数据区说法错误的是？**
```
A.如果线程正在执行Java方法，计数器记录的是虚拟机字节码指令的地址。如果正在执行本地方法，计数器值为空
B.如果JVM栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出StackOverflowError
C.可以通过-Xms设置堆的最大容量
D.Java要求常量只有编译期才能产生
```
---
**Q36：以下关于Java对象创建说法正确的是？**
```
A.当JVM遇到一条字节码new指令时，首先将检查该指令的参数能否在常量池中定位到一个类的直接引用，并检查这个引用代表的类是否已被加载、解析和初始化
B.假设Java堆内存是规整的，被使用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界指示器，分配内存就是把该指针向空闲方向挪动一段与对象大小相等的距离，这种方式叫"指针碰撞"
C.如果Java堆中的内存不是规整的，那么虚拟机就必须维护一个列表记录哪些内存块可用，在分配时从列表中找到一块足够大的空间划分给对象实例并更新列表上的记录，这种方式叫做"空闲列表"
D.对象分配内存的并发安全性问题可考虑用TLAB解决
```
---
**Q37：以下关于Java对象内存布局说法正确的是？**
```
A.对象头占用12B，存储内容包括对象标记和类元信息
B.实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有父类成员变量
C.类元信息存储的是对象指向它的类元数据的首地址，占用4B
D.对齐填充这部分不是必然存在的，仅起占位符的作用
```
-----
**Q38：以下关于Java对象的访问定位说法正确的是？**
```
A.Java程序会通过栈上的reference数据来操作堆上的具体对象，而具体对象访问方式是由虚拟机决定的，主流的访问方式主要有使用句柄和直接指针两种
B.如果使用句柄访问，优点是reference存储稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference本身不需要被修改
C.如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址
D.HotSpot虚拟机主要使用句柄访问来进行对象访问
```
---
**Q39：以下关于OOM说法正确的是？**
```
A.触发堆溢出：在 while 死循环中一直 new 创建实例
B.JDK7触发运行时常量池溢出：在 while 死循环中不断调用 intern 方法
C.触发方法区溢出：使用 JDK 反射或 CGLib 直接操作字节码在运行时生成大量的类
D.触发栈溢出：递归方法不断调用自己
```
---
**Q40：以下关于引用类型说法错误的是？**
```
A.在JDK1.2之后Java对引用的概念进行了扩充，按强度分为四种：强引用、弱引用、软引用、虚引用
B.在系统将要发生内存溢出异常前，会把弱引用关联的对象加入回收范围以获得更多的内存空间。
C.被软引用关联的对象只能生存到下一次 YGC 之前
D.一个对象是否有虚引用存在，完全不会对其生存时间造成影响
```
---
**Q41：以下关于GC算法说法正确的是？**
```
A.标记-复制算法：执行效率不稳定，如果堆中包含大量对象且其中大部分是需要被回收的，这时必须进行大量标记和清除，导致效率随对象数量增长而降低
B.标记-清除算法：实现简单、运行高效，解决了内存碎片问题
C.标记-整理算法：标记过程与标记-清除算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存
D.HotSpot虚拟机默认Eden和Survivor的大小比例是9：1
```
---
**Q42：以下关于垃圾收集器的说法错误的是？**
```
A.Serial是虚拟机运行在服务端模式下的默认新生代收集器，优点是简单高效，对于内存受限的环境它是所有收集器中最小的
B.ParNew是Serial的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致
C.Serial Old是虚拟机在服务端模式下的默认老年代收集器
D.CMS以获取最短回收停顿时间为目标的收集器，如果希望系统停顿时间尽可能短以给用户带来更好的体验就可以使用 CMS
```
---
**Q43：以 Seial + Serial Old 组合为例，以下关于JVM内存分配与回收策略说法正确的是？**
```
A.大多数情况下对象在新生代Eden区分配，当Eden区没有足够空间进行分配时将发起一次Minor GC
B.HotSpot提供了-XX:PretenureSizeThreshold参数，大于该值的对象直接在老年代分配，避免在Eden和Survivor间来回复制产生大量内存复制操作
C.对象在Survivor中每熬过一次MinorGC年龄就加1 ，当增加到一定程度（默认16）就会被晋升到老年代
D.发生Full GC前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Full GC可以确定是安全的
```
---
**Q44：以下不属于JVM基础故障处理工具的是？**
```
A.jstack：Java 堆栈跟踪工具
B.jhsdb：基于服务性代理的调试工具
C.jmap：Java 内存映像工具
D.jps：虚拟机进程状况工具
```
---
**Q45：以下关于Java程序运行过程说法正确的是？**
```
A.为了提高热点代码的执行效率，在运行时虚拟机会把这些代码编译成本地机器码，并尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器
B.词法解析，通过空格分割处单词、操作符、控制符等信息，将其形成 token 信息流
C.语法解析，检查关键字的使用是否合理、类型是否匹配、作用域是否正确等
D.语义分析：把词法解析得到的 token 信息流按规则组装成语法树
```
---
**Q46：关于何时开始类加载的第一个阶段"加载"，《 Java 虚拟机规范》没有强制约束，但对于初始化严格规定了有且只有6种情况，以下属于该情况的是？**
```
A.遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，类型还没有初始化
B.子类使用父类的静态字段，子类还没有初始化
C.对类型进行反射调用时，类型还没有初始化
D.通过数组定义使用类，类还没有初始化
```
---
**Q47：以下关于Java类加载说法正确的是？**
```
A.验证是未来确保 Class 文件的字节流中包含的信息符合约束要求，包含了四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证
B.准备是正式为类所有已定义变量分配内存并设置零值的阶段
C.解析是将常量池内的符号引用替换为直接引用的过程
D.初始化是类加载过程的最后一步，直到该阶段，JVM 才真正开始执行类中编写的代码
```
-----
**Q48：以下关于类加载器相关说法正确的是？**
```
A.类加载阶段中"通过一个类的全限定名来获取描述该类的二进制字节流"的动作被设计为放到 JVM 外部实现，以便让应用程序自己决定如何获取所需的类，实现这个动作的代码就是类加载器
B.从JDK8开始从扩展类加载器更换为平台类加载器，负载加载一些扩展的系统类
C.类加载器具有等级制度，但并非继承关系，以组合的方式来复用父加载器的功能，这也符合组合优先原则
D.比较两个类是否相同：类名和包名都全部相同
```
---
**Q49：以下关于JMM说法正确的是？**
```
A.JMM遵循一个原则：只要不改变程序执行结果，编译器和处理器怎么优化都行
B.JMM的主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节，此处的变量包括实例字段、静态字段、构成数组元素的对象、局部变量等
C.JMM规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作空间中进行，而不能直接读写主内存中的数据
D.JMM将 happens-before 要求禁止的重排序按是否会改变程序执行结果分为两类。对于会改变结果的重排序 JMM 要求编译器和处理器必须禁止这种重排序，对于不会改变结果的重排序，JMM 对编译器和处理器不做要求
```
---
**Q50：以下关于Java并发原子性、可见性、有序性 说法正确的是？**
```
A.volatile可以保证可见性、有序性
B.synchronized可以保证原子性、可见性和有序性
C.JSR-133增强了volatile 语义，严格限制了编译器和处理器对volatile变量与普通变量的重排序，确保 volatile的读-写和锁的释放-获取具有相同的内存语义
D.final可以保证可见性和有序性
```
---
【1】比较排序包括插入排序、选择排序、交换排序和归并排序，非比较排序包括计数排序、基数排序和桶排序。因此答案为ACD。
【2】稳定的排序包括直接插入、冒泡排序和归并排序，不稳定排序包括希尔排序、直接选择排序、堆排序和快速排序。因此答案为ABC。
【3】数据规模中等，选择希尔排序；数据规模较大，考虑堆排序（元素分布接近正序或逆序）、快速排序（元素分布随机）和归并排序（稳定性）。因此答案为ABC。
【4】创建型模式包括工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式；结构型模式包括包括适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式；责任链模式包括包括责任链模式、命名模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式、访问者模式。因此答案为ACD。
【5】简单工厂模式指由一个工厂对象来创建实例，客户端不需要关注创建的逻辑，只需要提供传入工厂对象的参数；抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。答案为B。
【6】通过 `Proxy ` 类的 `newInstance` 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 `InvocationHandler` 调用处理器来指明具体的逻辑。答案为D。
【7】英文字符永远占 1B，中文字符在 UTF-8 占 3B，GBK 占 2B。答案为AC。
【8】double的取值范围是±1.7E+308（有效位数 15 位）；JVM 并没有针对 boolean 类型进行赋值的专用字节码指令，`boolean f = false` 就是使用 ICONST_0，即常数 0 来进行赋值。单个boolean 变量用 int 代替，而 boolean 数组会编码成 byte 数组。答案为CD。
【9】只要参与拼接的字符串里有变量，结果就在堆中。答案D。
【10】方法不能修改基本数据类型的参数，可以改变对象参数的状态，但不能让对象参数引用一个新的对象。答案D。
【11】封装中对属性的访问和修改必须通过公共接口实现；面向对象的代码强调低耦合，高内聚；封装使对象之间的关系变得简单，降低了代码耦合度，有利维护。答案为ABC。
【12】重载是指方法名称相同，但是参数类型或参数个数不相同，是水平方向上行为的不同实现；重写的子类方法访问权限不能变小，返回类型和抛出的异常类型不能变大。答案为AD。
【13】JVM 在重载方法中，选择合适的目标方法的顺序：① 精确匹配。② 如果是基本数据类型，自动转换成更大表示范围的基本类型。③ 通过自动拆箱与装箱。④ 通过子类向上转型继承路线依次匹配。⑤ 通过可变参数匹配。答案A。
【14】组合是比聚合更强的关系：contains-a，聚合是暂时组装的关系：has-a。答案CD。
【15】字符串可能有相同的散列码，因为字符串的散列码是由内容导出的；为了在集合中正确使用对象，一般需要同时重写 equals 和 hashCode 方法，要求是 equals 相同 hashCode 必须相同，但 hashCode 相同时 equals 未必相同，因此 hashCode 是两个对象相同的必要不充分条件。答案ACD。
【16】clone 方法声明为 protected，类只能通过该方法克隆它自己的对象；一般重写 clone 方法需要实现 Cloneable 接口并指定访问修饰符为 public；由于运行代价高昂，不确定性大，无法保证各个对象的调用顺序，在 JDK 9 已经被标记为过时方法，因此它并不适合释放资源，释放资源可以使用 try-finally 代码块。答案为ABC。
【17】局部内部类定义在方法或者表达式内部，不能声明访问修饰符；内部类是一个编译器现象，与虚拟机无关，编译器会把内部类转换成常规的类文件，虚拟机对此一无所知。答案CD。
【18】接口在被实现时体现的是 can-do 关系；抽象类是模板式设计；抽象类有构造方法。答案A。
【19】先静后普构造方法放最后，自己发明的愚蠢口令，答案A。
【20】序列化和反序列化必须保持序列化ID一致，一般使用 `private static final long serialVersionUID` 定义；使用 Java 原生序列化不会调用类的无参构造方法，而是调用本地方法将成员变量赋值为对应类型的初始值。答案AB。
【21】获取 Class 实例的方法有三种：① 直接通过 `类名.class` 。②通过对象的 `getClass()`方法。③通过 `Class.forName(类的全限定名)`。答案为D。
【22】getFields、getMethods和getConstructors方法包括父类成员；getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法不包括父类成员。答案为AB。
【23】元注解是自定义注解的注解；`@Rentention`值是 RetentionPolicy 枚举类实例。答案为BD。
【24】UnAuthorizedException属于受检异常；进行 RPC 调用时产生的远程服务超时异常，这类异常是客户端必须显式处理的，但属于非受检异常。答案为AC。
【25】对泛型上限的限定使用<? extends T>，它表示该通配符所代表的类型是 T 类的子类型或 T 接口的子接口，对泛型下限的限定使用<? super T>，它表示该通配符所代表的类型是 T 类的父类型或 T 接口的父接口；N表示数值类型。答案为CD。
【26】不多说，答案ABCD。
【27】AIO只处理有效请求；同步和异步是通信机制，阻塞和非阻塞是调用状态。答案AB。
【28】buffe本质是一块可读写数据的内存，用来简化数据的读写。其三个重要属性：position 表示下一次读写数据的位置，limit 表示本次读写的极限位置，capacity 表示最大容量。`flip()` 将写转为读，底层实现原理是把 position 置 0，并把 limit 设为当前的 position 值。通过 `clear()` 将读转为写模式（用于读完全部数据的情况，把 position 置 0，limit 设为 capacity）；适应场景：连接数目多、连接时间短。答案为A。
【29】elementData是ArrayList 的数据域，被 transient 修饰，在类的序列化时被忽视，集合序列化时会调用 writeObject 写入流中，在网络客户端反序列化的 readObject 中会重新赋值到新对象的 elementData 中。之所以这样做的原因是 elementData 容量通常会大于实际存储元素的数量（size），所以只需发送真正有实际值的数组元素即可；fail-safe 是在安全的副本上进行遍历，集合修改与副本的遍历没有任何关系，但缺点就是无法读取到最新的数据，ArrayList的机制是fail-fast。答案为AD。
【30】LinkedList 的优点在于可以将零散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高；成员变量 capacityIncrement是Vector的属性。答案为AD。
【31】对于引用数据类型，会先比较 hashCode 返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较 equals 方法返回值是否相同，都相同说明是同一个对象；对TreeMap的Key排序。答案BC。
【32】红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：① 节点只能是红色或黑色。② 根节点必须是黑色。③ 所有 NIL 节点都是黑色的。④ 一条路径上不能出现相邻的两个红色节点。⑤ 在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点。这五个约束条件保证了红黑树的新增、删除、查找的最坏时间复杂度均为 O(log~n~)。答案ABD。
【33】插入的 Key 必须实现 Comparable 接口或提供额外的 Comparator 比较器，所以 Key 不允许为 null；HashMap 是依靠 hashCode 和 equals 来去重的，而 TreeMap 依靠 Comparable 或 Comparator 来实现去重。答案A。
【34】JDK8的HashMap使用尾插法扩容。答案ABC。
【35】当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常；可以通过 -Xms 和 -Xmx 设置堆的最小和最大容量；Java 并不要求常量一定只有编译期才能产生，也就是说并非预置入 Class 文件常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，例如 String 类的 `intern` 方法。答案BCD。
【36】首先将检查该指令的参数能否在常量池中定位到一个类的符号引用。答案BCD。
【37】实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。答案ACD。
【38】HotSpot 主要使用直接指针来进行对象访问。答案ABC。
【39】在 JDK 6 及之前常量池都分配在永久代，因此可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制永久代大小，间接限制常量池。在 while 死循环中不断调用 intern 方法导致运行时常量池溢出。在 JDK 7 及之后不会出现该问题，因为存放在永久代的字符串常量池已经被移至 Java 堆中。答案ACD。
【40】强引用>软引用>弱引用>虚引用； 在系统将要发生内存溢出异常前，会把软引用关联的对象加入回收范围以获得更多的内存空间；被弱引用关联的对象只能生存到下一次 YGC 之前。答案ABC。
【41】A是标记清除算法；B是标记复制算法；HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。答案C。
【42】Serial和Serial Old都是虚拟机在客户端模式下默认的收集器。答案AC。
【43】对象在Survivor中每熬过一次MinorGC年龄就加1 ，当增加到一定程度（默认15）就会被晋升到老年代；发生 MinorGC 前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 MinorGC可以确定是安全的。答案AC。
【44】JVM基础故障处理工具包括：jps、jstat、jinfo、jmap、jhat、jstack；除了基础故障处理工具，还有一些可视化故障处理工具，例如 JHSDB 基于服务性代理的调试工具、JConsole Java 监视与管理控制台、VisualVM 多合一故障处理工具、Java Mission Control 可持续在线监控工具。答案B。
【45】语法解析，把词法解析得到的 token 信息流按照 Java 语法规则组装成一颗语法树；语义分析，检查关键字的使用是否合理、类型是否匹配、作用域是否正确等。答案AB。
【46】被动引用的实例：① 子类使用父类的静态字段时，只有直接定义这个字段的父类会被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。答案AC。
【47】准备是正式为类静态变量分配内存并设置零值的阶段，该阶段进行的内存分配仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。如果变量被final修饰，编译时 Javac 会为变量生成 ConstantValue 属性，那么在准备阶段虚拟机就会将该变量的值设为程序员指定的值。答案ACD。
【48】从 JDK9 开始从扩展类加载器更换为平台类加载器；对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。只有在两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要加载它们的类加载器不同，那这两个类就必定不相等。答案AC。
【49】变量包括实例字段、静态字段和构成数组元素的对象，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争问题。答案ACD。
【50】在旧的内存模型中，虽然不允许 volatile 变量之间重排序，但允许 volatile 变量与普通变量重排序，可能导致内存不可见问题。为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写-读和锁的释放-获取具有相同的内存语义；final只能保证可见性，被 final 修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把 this 的引用传递出去，那么在其他线程中就能看见 final 字段的值。答案AB。