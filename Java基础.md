java内存模型，gc工作原理

在构造函数中：
this.a = a;
表示给成员变量赋值。this.a表示这个类的成员变量a



# 1. Java实现类

1.Collection接口:子类有List接口，Queue接口以及Set接口
增：add(Object obj)，插入末尾
删：remove(Object obj)
Object[] toArray():返回一个内含集合所有元素的数组
Object[] toString():将 arraylist 转换为字符串
Iterator iterator(),返回一个迭代器
长度：size()
遍历：① Iterator迭代器方式
 ② 增强for循环
 ③ 普通的循环
方法：
https://www.cnblogs.com/chanshuyi/p/4468467.html
概念：
https://my.oschina.net/u/4391166/blog/3538791

2.Queue接口：实现类PriorityQueue，ArrayDeque、LinkedList
Queue<Integer> q = new LinkedList<>();
add()和offer()：都是向队列中添加一个元素
remove() 和 poll()：都是从队列中删除第一个元素
element() 和 peek()：返回队列头部的元素。remove：移除并返回队列头部的元素
方法：
https://blog.csdn.net/u012050154/article/details/60572567

3.List接口:List接口由ArrayList，LinkedList，Vector和Stack实现类实现
插：add(int index, E element)：可以在特定位置插入删除元素，而不只是插入集合末尾
删除集合中特定下标的元素：remove(int index)
改：set(int index, Object ele)
查：get(int index)
获取特定元素下标：indexOf(Object o) / lastIndexOf(Object o)
https://blog.csdn.net/erlian1992/article/details/51298276


4.ArrayList
ArrayList<E> objectName =new ArrayList<>();　 // 初始化
https://www.runoob.com/java/java-arraylist.html


5.LinkedList
LinkedList<E> list = new LinkedList<E>();   // 普通创建方法
https://www.runoob.com/java/java-linkedlist.html



ArrayList 是线性表（数组）
get() 直接读取第几个下标，复杂度 O(1)
add(E) 添加元素，直接在后面添加，复杂度O（1）
add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）
remove（）删除元素，后面的元素需要逐个移动，复杂度O（n）

LinkedList 是链表的操作
get() 获取第几个元素，依次遍历，复杂度O(n)
add(E) 添加到末尾，复杂度O(1)
add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)
remove（）删除元素，直接指针指向操作，复杂度O(1)



# 2. Java异常处理

Throwable： 有两个重要的子类：Exception（异常）和 Error（错误）

Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些错误发生时，Java虚拟机（JVM）一般会选择线程终止


运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。

非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

try,catch,finally:
不管try有没有出错finally方法块都会被执行。【快记笔记，知识点。】
就算try和catch方法都有return，finally都会执行；
只要try或者catch return返回，try catch 之外的return都无效；
说到这里有些不懂得人可能会有疑问？那在finally写个return是什么结果哪？很不幸的告诉你，不能这么写，写了会怎么样，哼会提示：控制不能离开finally子句主体;
try-finally可以运行;
try如果没有catch但是发生异常会向上找catch方法块来捕获。知道没有系统崩溃。





# 3.拷贝

clone默认浅拷贝
浅拷贝：我们这里说的浅拷贝是指我们拷贝出来的对象内部的引用类型变量和原来对象内部引用类型变量是同一引用（指向同一对象）。
但是我们拷贝出来的对象和新对象不是同一对象。

简单来说，新（拷贝产生）、旧（元对象）对象不同，但是内部如果有引用类型的变量，新、旧对象引用的都是同一引用。

深拷贝：全部拷贝原对象的内容，包括内存的引用类型也进行拷贝





# 4.抽象类和接口

抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象方法。
抽象方法用abstract修饰，只能是public或者protected（private不能被子类继承）
抽象类不能被实例化。
抽象类的使用必须有子类，使用extends继承，一个子类只能继承一个抽象类。
子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）
抽象类可以不包含抽象方法，但如果类中包含抽象方法，就必须将该类声明为抽象类。
抽象类的普通方法子类可直接使用，不用重写。


一个类可以实现多个接口，但只可以继承一个抽象类
 Java的interface中，成员变量的默认修饰符为public static final。方法的默认修饰符是：public abstract
一个非抽象的类，必须实现接口的所有声明的方法。抽象类实现接口，可以不全实现，但是他的子类必须实现所有剩余方法





# 5.静态代理与动态代理

静态代理：这种代理方式需要代理对象和目标对象实现一样的接口。
目标对象类，代理对象类

动态代理利用了JDK API
静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件
动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中
特点：
动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。


cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。

cglib特点：

JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。
如果想代理没有实现接口的类，就可以使用CGLIB实现。
CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。
它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。
CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。
不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。

cglib与动态代理最大的区别就是：

使用动态代理的对象必须实现一个或多个接口
使用cglib代理的对象则无需实现接口，达到代理类无侵入。







# 6. Java的反射

Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。 这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。 反射被视为动态语言的关键。


Class.forName( )静态方法的目的是为了动态加载类。在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作。因此，单单使用Class.forName( )是动态加载类是没有用的，其最终目的是为了实例化对象。
那么Class下的newInstance()和new有什么区别？首先，newInstance( )是一个方法，而new是一个关键字。其次，Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用new关键字生成对象没有这个限制。
Class.forName("")返回的是类
Class.forName("").newInstance()返回的是object





# 7. Java对象的创建过程：

1.虚拟机在遇到一条new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析、和初始化过。如果没有，那么必须先执行相应的类加载过程。

2.（此处先检查类加载，未加载则进行加载）在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需要的内存等大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来

3.分配完内存后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一项工作也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型锁对应的零值。

4.接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到这个类的元素据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象都会有不同的设置方式。

5.上面的工作都完成后，从虚拟机角度来看，一个新的对象已经产生了，但从Java程序的角度来看，对象创建才刚刚开始——<init>方法还没执行，所有的字段都为零。所以，一般来说，执行new指令之后接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。







# 8. static

static是一个修饰符，用于修饰成员（成员变量、成员方法）。在类A中被static修饰的变量是一种被A类对象所共享的数据，不仅可以被A类对象调用，也可以通过类名A直接调用。
【static 的特点】
（1）static成员优先于类定义的对象存在，因为static的成员在类的加载时就已经存在了；
（2）static修饰的成员多了一种调用方式,即：类名.静态成员；
（3）static修饰的数据是共享数据，对象中存储的是特有数据。


成员变量和局部变量的区别
       成员变量：
          ①成员变量定义在类中，在整个类中都可以被访问。
          ②成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。
          ③成员变量有默认初始化值。
      局部变量：
          ①局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。
          ②局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。
          ③局部变量没有默认初始化值

成员变量和静态变量的区别
      1、两个变量的生命周期不同
            成员变量随着对象的创建而存在，随着对象被回收而释放。
            静态变量随着类的加载而存在，随着类的消失而消失。
      2、调用方式不同
            成员变量只能被对象调用。
            静态变量可以被对象调用，还可以被类名调用。
      3、别名不同
            成员变量也称为实例变量。
            静态变量也称为类变量。
      4、数据存储位置不同
            成员变量存储在堆内存的对象中，所以也叫对象的特有数据。
            静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。